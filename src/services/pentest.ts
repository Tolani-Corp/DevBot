/**
 * pentest.ts
 *
 * AI-driven security scanning service for the FreakMe.fun platform.
 * Orchestrates pentest-runner tools and uses Claude to interpret results
 * and generate actionable security findings.
 *
 * Scan types supported:
 *  - dependency-audit : npm/pnpm vulnerability audit
 *  - secret-scan      : detect leaked credentials in source code
 *  - web-security     : HTTP headers, TLS, OWASP Top-10 probing
 *  - port-scan        : nmap-based network surface mapping
 *  - full             : all of the above + AI analysis
 */

import Anthropic from "@anthropic-ai/sdk";
import { Octokit } from "@octokit/rest";
import {
  auditDependencies,
  scanForSecrets,
  probeEndpoint,
  enumerateDNS,
  runPortScan,
  type PortScanResult,
  type DependencyAuditResult,
  type SecretScanResult,
  type EndpointProbeResult,
  type DNSEnumResult,
} from "@/services/pentest-runner";
import { validatePentestScan } from "@/middleware/validators";
import { sanitizeShellArg } from "@/middleware/sanitizer";

const client = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY! });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
const MODEL = process.env.ANTHROPIC_MODEL ?? "claude-sonnet-4-20250514";
const GITHUB_ORG = process.env.GITHUB_ORG ?? "Tolani-Corp";

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Types
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export type ScanType = "dependency-audit" | "secret-scan" | "web-security" | "port-scan" | "full";
export type Severity = "critical" | "high" | "medium" | "low" | "info";

export interface PentestFinding {
  id: string;
  severity: Severity;
  category: string;
  title: string;
  description: string;
  evidence: string;
  cvss?: number;
  cve?: string;
  remediation: string;
  references: string[];
}

export interface PentestReport {
  scanId: string;
  target: string;
  scanType: ScanType;
  startedAt: Date;
  completedAt: Date;
  findings: PentestFinding[];
  summary: PentestSummary;
  rawData: PentestRawData;
  aiAnalysis: string;
}

export interface PentestSummary {
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  infoCount: number;
  totalFindings: number;
  riskScore: number;         // 0â€“100
  riskRating: "critical" | "high" | "medium" | "low" | "clean";
  topRecommendation: string;
}

export interface PentestRawData {
  portScan?: PortScanResult;
  dependencyAudit?: DependencyAuditResult;
  secretScan?: SecretScanResult;
  endpointProbes?: EndpointProbeResult[];
  dnsEnum?: DNSEnumResult;
}

export interface ScanOptions {
  /** Repository path on disk (for secret scan + dep audit) */
  repoPath?: string;
  /** Owner/repo on GitHub (for fetching context) */
  repository?: string;
  /** URLs to probe for web security checks */
  urls?: string[];
  /** Network host for port scanning */
  host?: string;
  portRange?: string;
  /** Must be explicitly true â€” audit trail confirmation */
  authorized: boolean;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Entry Point
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Run a pentest scan against a target.
 * Returns a structured PentestReport with AI-interpreted findings.
 */
export async function runPentestScan(
  target: string,
  scanType: ScanType,
  options: ScanOptions
): Promise<PentestReport> {
  // Authorization gate â€” must explicitly confirm before any scan
  validatePentestScan({
    target,
    scanType,
    repository: options.repository,
    authorized: options.authorized,
  });

  const scanId = `scan-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const startedAt = new Date();
  const rawData: PentestRawData = {};
  const findings: PentestFinding[] = [];

  // â”€â”€ Run modules in parallel where possible â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const tasks: Promise<void>[] = [];

  if (scanType === "dependency-audit" || scanType === "full") {
    if (options.repoPath) {
      tasks.push(
        auditDependencies(options.repoPath)
          .then((result) => {
            rawData.dependencyAudit = result;
            findings.push(...dependencyAuditToFindings(result));
          })
          .catch((err) => {
            findings.push(errorFinding("dependency-audit", String(err)));
          })
      );
    }
  }

  if (scanType === "secret-scan" || scanType === "full") {
    if (options.repoPath) {
      tasks.push(
        scanForSecrets(options.repoPath)
          .then((result) => {
            rawData.secretScan = result;
            findings.push(...secretScanToFindings(result));
          })
          .catch((err) => {
            findings.push(errorFinding("secret-scan", String(err)));
          })
      );
    }
  }

  if (scanType === "web-security" || scanType === "full") {
    const urls = options.urls ?? (target.startsWith("http") ? [target] : []);
    if (urls.length > 0) {
      tasks.push(
        Promise.all(urls.slice(0, 10).map((u) => probeEndpoint(u)))
          .then((results) => {
            rawData.endpointProbes = results;
            findings.push(...endpointProbesToFindings(results));
          })
          .catch((err) => {
            findings.push(errorFinding("web-security", String(err)));
          })
      );
    }

    // DNS enum for domain targets
    const domain = extractDomain(target);
    if (domain) {
      tasks.push(
        enumerateDNS(domain)
          .then((result) => { rawData.dnsEnum = result; })
          .catch(() => {}) // Non-fatal
      );
    }
  }

  if (scanType === "port-scan" || scanType === "full") {
    const host = options.host ?? extractDomain(target) ?? "";
    if (host) {
      tasks.push(
        runPortScan(host, options.portRange, { serviceVersion: true })
          .then((result) => {
            rawData.portScan = result;
            findings.push(...portScanToFindings(result));
          })
          .catch((err) => {
            findings.push(errorFinding("port-scan", String(err)));
          })
      );
    }
  }

  await Promise.allSettled(tasks);

  // â”€â”€ AI Analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const aiAnalysis = await analyzeWithClaude(target, scanType, findings, rawData);

  const completedAt = new Date();
  const summary = buildSummary(findings);

  return {
    scanId,
    target,
    scanType,
    startedAt,
    completedAt,
    findings: findings.sort((a, b) => severityRank(b.severity) - severityRank(a.severity)),
    summary,
    rawData,
    aiAnalysis,
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Converter: Raw Tool Output â†’ Typed Findings
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function dependencyAuditToFindings(audit: DependencyAuditResult): PentestFinding[] {
  return audit.vulnerabilities.map((v, i) => ({
    id: `dep-${i}`,
    severity: v.severity === "moderate" ? "medium" : v.severity,
    category: "Vulnerable Dependency",
    title: `${v.severity.toUpperCase()}: ${v.name} â€” ${v.description.slice(0, 80)}`,
    description: v.description,
    evidence: `Package: ${v.name}\nAffected Range: ${v.range}\nCVSS: ${v.cvss ?? "N/A"}`,
    cvss: v.cvss,
    cve: v.cve,
    remediation: v.fixedIn
      ? `Upgrade ${v.name} to ${v.fixedIn} or later. Run: ${audit.packageManager} update ${v.name}`
      : `Remove or replace ${v.name}. No fixed version currently available.`,
    references: v.cve ? [`https://nvd.nist.gov/vuln/detail/${v.cve}`] : [],
  }));
}

function secretScanToFindings(scan: SecretScanResult): PentestFinding[] {
  return scan.findings.map((f, i) => ({
    id: `secret-${i}`,
    severity: f.severity,
    category: "Exposed Secret / Credential",
    title: `${f.type} found in ${f.file}:${f.line}`,
    description:
      `A ${f.type} was detected in the source code. ` +
      `If committed to a public or shared repository, this credential may be compromised.`,
    evidence: `File: ${f.file}\nLine: ${f.line}\nMatch (redacted): ${f.match}`,
    remediation:
      `1. Immediately rotate/revoke the exposed credential.\n` +
      `2. Remove the secret from source code and use environment variables instead.\n` +
      `3. Run 'git filter-repo' or BFG to purge from git history.\n` +
      `4. Add '*.env' and secret patterns to .gitignore.`,
    references: ["https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password"],
  }));
}

function endpointProbesToFindings(probes: EndpointProbeResult[]): PentestFinding[] {
  const findings: PentestFinding[] = [];
  let idx = 0;

  for (const probe of probes) {
    if (probe.error) {
      findings.push({
        id: `web-err-${idx++}`,
        severity: "info",
        category: "Endpoint Unreachable",
        title: `Could not reach ${probe.url}`,
        description: probe.error,
        evidence: `URL: ${probe.url}\nError: ${probe.error}`,
        remediation: "Verify the URL is correct and the server is running.",
        references: [],
      });
      continue;
    }

    // Missing security headers
    for (const headerCheck of probe.securityHeaders) {
      if (!headerCheck.present) {
        const sev: Severity = ["Content-Security-Policy", "Strict-Transport-Security"].includes(headerCheck.header)
          ? "high"
          : "medium";
        findings.push({
          id: `header-${idx++}`,
          severity: sev,
          category: "Missing Security Header",
          title: `Missing ${headerCheck.header} on ${probe.url}`,
          description: `The ${headerCheck.header} HTTP response header is absent. This may leave users vulnerable to common web attacks.`,
          evidence: `URL: ${probe.url}\nStatus: ${probe.statusCode}\nAll headers: ${JSON.stringify(probe.headers, null, 2).slice(0, 500)}`,
          remediation: headerCheck.recommendation,
          references: ["https://owasp.org/www-project-secure-headers/"],
        });
      }
    }

    // TLS issues
    if (probe.tlsInfo && !probe.tlsInfo.authorized) {
      findings.push({
        id: `tls-${idx++}`,
        severity: "high",
        category: "TLS Certificate Issue",
        title: `Invalid/unauthorized TLS certificate on ${probe.url}`,
        description: "The TLS certificate is not authorized â€” it may be self-signed, expired, or for a different domain.",
        evidence: `Protocol: ${probe.tlsInfo.protocol}\nCipher: ${probe.tlsInfo.cipher}\nExpires: ${probe.tlsInfo.expiresAt ?? "unknown"}`,
        remediation: "Install a valid TLS certificate from a trusted CA (Let's Encrypt, DigiCert, etc.).",
        references: ["https://owasp.org/www-project-transport-layer-protection-cheat-sheet/"],
      });
    }

    // Exposed server info
    if (probe.headers["server"] || probe.headers["x-powered-by"]) {
      findings.push({
        id: `info-${idx++}`,
        severity: "low",
        category: "Information Disclosure",
        title: `Server version disclosure on ${probe.url}`,
        description: "The server returns its software name and/or version in response headers. This aids fingerprinting.",
        evidence: `Server: ${probe.headers["server"] ?? "N/A"}\nX-Powered-By: ${probe.headers["x-powered-by"] ?? "N/A"}`,
        remediation: "Remove or obscure 'Server' and 'X-Powered-By' headers in your web server config.",
        references: ["https://owasp.org/www-project-web-security-testing-guide/"],
      });
    }
  }

  return findings;
}

function portScanToFindings(scan: PortScanResult): PentestFinding[] {
  const RISKY_PORTS: Record<number, { description: string; severity: Severity }> = {
    21:    { description: "FTP â€” unencrypted file transfer. Use SFTP instead.", severity: "high" },
    23:    { description: "Telnet â€” unencrypted remote shell. Use SSH instead.", severity: "critical" },
    110:   { description: "POP3 â€” unencrypted email. Use POP3S (995) instead.", severity: "medium" },
    143:   { description: "IMAP â€” unencrypted email. Use IMAPS (993) instead.", severity: "medium" },
    445:   { description: "SMB â€” Windows file sharing. Commonly exploited (EternalBlue).", severity: "high" },
    3389:  { description: "RDP â€” Windows Remote Desktop exposed to internet. High risk.", severity: "critical" },
    5432:  { description: "PostgreSQL database directly exposed. Should be firewalled.", severity: "critical" },
    3306:  { description: "MySQL database directly exposed. Should be firewalled.", severity: "critical" },
    6379:  { description: "Redis exposed without auth. Commonly compromised.", severity: "critical" },
    27017: { description: "MongoDB exposed. Common cryptominer target.", severity: "critical" },
    5900:  { description: "VNC remote desktop exposed.", severity: "high" },
  };

  return scan.openPorts.map((port, i) => {
    const risk = RISKY_PORTS[port.port];
    return {
      id: `port-${i}`,
      severity: risk?.severity ?? "info",
      category: "Open Port / Exposed Service",
      title: `Port ${port.port}/${port.service} open on ${scan.host}`,
      description: risk?.description ?? `Port ${port.port} (${port.service}) is open and reachable.`,
      evidence: `Host: ${scan.host}\nPort: ${port.port}\nService: ${port.service} ${port.version}`.trim(),
      remediation: risk
        ? risk.description
        : `Verify this port should be publicly accessible. Apply firewall rules to restrict access if not needed.`,
      references: [],
    };
  });
}

function errorFinding(category: string, message: string): PentestFinding {
  return {
    id: `err-${category}-${Date.now()}`,
    severity: "info",
    category: "Scan Error",
    title: `${category} scan could not complete`,
    description: message,
    evidence: message,
    remediation: "Check tool availability and target accessibility.",
    references: [],
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Claude AI Analysis
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function analyzeWithClaude(
  target: string,
  scanType: ScanType,
  findings: PentestFinding[],
  rawData: PentestRawData
): Promise<string> {
  const findingsSummary = findings
    .slice(0, 30) // Cap to avoid huge prompts
    .map((f) => `[${f.severity.toUpperCase()}] ${f.title}\n  ${f.description.slice(0, 200)}`)
    .join("\n\n");

  const prompt = `You are a senior penetration tester reviewing automated scan results for the FreakMe.fun platform â€” an adult content creator platform with Web3 integration, React/Vite frontend, Python backend, Convex database, and Stripe payments.

## Scan Target
${target}

## Scan Type
${scanType}

## Automated Findings (${findings.length} total)

${findingsSummary || "No automated findings detected."}

## Context
${rawData.portScan ? `Open ports: ${rawData.portScan.openPorts.map((p) => `${p.port}/${p.service}`).join(", ")}` : ""}
${rawData.dependencyAudit ? `Dependency audit: ${rawData.dependencyAudit.totalVulns} vulns (${rawData.dependencyAudit.criticalCount} critical, ${rawData.dependencyAudit.highCount} high)` : ""}
${rawData.secretScan ? `Secret scan: ${rawData.secretScan.totalFindings} potential secrets in ${rawData.secretScan.filesScanned} files` : ""}
${rawData.endpointProbes ? `Endpoint probes: ${rawData.endpointProbes.length} URLs checked` : ""}

## Your Task

1. **Executive Risk Summary** (2-3 sentences) â€” overall risk posture
2. **Top 3 Priority Actions** â€” the highest-impact fixes, ordered by riskÃ—effort
3. **Platform-Specific Risks** â€” given this is an adult creator platform with payments, crypto, and user-generated content uploads, what attack vectors are especially relevant?
4. **Quick Wins** â€” fixes that can be done in under 30 minutes
5. **False Positive Flags** â€” any findings that are likely false positives for this stack?

Be specific, actionable, and concise. Reference specific findings where relevant.`;

  try {
    const message = await client.messages.create({
      model: MODEL,
      max_tokens: 1500,
      messages: [{ role: "user", content: prompt }],
    });

    return message.content
      .filter((b) => b.type === "text")
      .map((b) => (b as any).text)
      .join("\n");
  } catch (err) {
    return `AI analysis unavailable: ${String(err)}`;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Summary Builder
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildSummary(findings: PentestFinding[]): PentestSummary {
  const counts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };
  for (const f of findings) counts[f.severity]++;

  // Weighted risk score 0-100
  const score = Math.min(
    100,
    counts.critical * 25 +
    counts.high * 10 +
    counts.medium * 3 +
    counts.low * 1
  );

  const rating: PentestSummary["riskRating"] =
    score >= 50 ? "critical" :
    score >= 25 ? "high" :
    score >= 10 ? "medium" :
    score > 0   ? "low" :
    "clean";

  const topFinding = findings.find((f) => f.severity === "critical" || f.severity === "high");
  const topRecommendation = topFinding?.remediation?.split("\n")[0] ?? "No critical findings â€” maintain regular scanning cadence.";

  return {
    criticalCount: counts.critical,
    highCount: counts.high,
    mediumCount: counts.medium,
    lowCount: counts.low,
    infoCount: counts.info,
    totalFindings: findings.length,
    riskScore: score,
    riskRating: rating,
    topRecommendation,
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Slack Report Formatter
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Format a pentest report as a Slack Block Kit message.
 */
export function formatReportForSlack(report: PentestReport): any[] {
  const { summary } = report;
  const emoji =
    summary.riskRating === "critical" ? "ğŸ”´" :
    summary.riskRating === "high"     ? "ğŸŸ " :
    summary.riskRating === "medium"   ? "ğŸŸ¡" :
    summary.riskRating === "low"      ? "ğŸŸ¢" :
                                        "âœ…";

  const blocks: any[] = [
    {
      type: "header",
      text: { type: "plain_text", text: `${emoji} Security Scan: ${report.target}` },
    },
    {
      type: "section",
      fields: [
        { type: "mrkdwn", text: `*Scan Type*\n${report.scanType}` },
        { type: "mrkdwn", text: `*Risk Score*\n${summary.riskScore}/100 (${summary.riskRating.toUpperCase()})` },
        { type: "mrkdwn", text: `*Critical*\n${summary.criticalCount}` },
        { type: "mrkdwn", text: `*High*\n${summary.highCount}` },
        { type: "mrkdwn", text: `*Medium*\n${summary.mediumCount}` },
        { type: "mrkdwn", text: `*Low*\n${summary.lowCount}` },
      ],
    },
    { type: "divider" },
    {
      type: "section",
      text: { type: "mrkdwn", text: `*Top Recommendation*\n${summary.topRecommendation}` },
    },
  ];

  // Show top 5 findings
  const topFindings = report.findings.slice(0, 5);
  if (topFindings.length > 0) {
    blocks.push({ type: "divider" });
    blocks.push({
      type: "section",
      text: { type: "mrkdwn", text: `*Top Findings (${report.findings.length} total)*` },
    });
    for (const f of topFindings) {
      const sev = f.severity.toUpperCase();
      blocks.push({
        type: "section",
        text: {
          type: "mrkdwn",
          text: `*[${sev}]* ${f.title}\n_${f.description.slice(0, 150)}_`,
        },
      });
    }
  }

  // AI Analysis (truncated)
  if (report.aiAnalysis) {
    blocks.push({ type: "divider" });
    blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*AI Analysis*\n${report.aiAnalysis.slice(0, 2500)}`,
      },
    });
  }

  blocks.push({
    type: "context",
    elements: [
      {
        type: "mrkdwn",
        text: `Scan ID: \`${report.scanId}\` | Completed: ${report.completedAt.toISOString()}`,
      },
    ],
  });

  return blocks;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  GitHub Security Report
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Post a pentest report as a GitHub issue in the target repository.
 */
export async function postReportAsGitHubIssue(
  owner: string,
  repo: string,
  report: PentestReport
): Promise<string> {
  const { summary } = report;
  const label =
    summary.riskRating === "critical" ? "severity: critical" :
    summary.riskRating === "high"     ? "severity: high" :
    "security";

  const criticalAndHigh = report.findings
    .filter((f) => f.severity === "critical" || f.severity === "high")
    .slice(0, 20)
    .map(
      (f) =>
        `### [${f.severity.toUpperCase()}] ${f.title}\n\n` +
        `**Category:** ${f.category}\n\n` +
        `**Description:** ${f.description}\n\n` +
        `**Evidence:**\n\`\`\`\n${f.evidence}\n\`\`\`\n\n` +
        `**Remediation:** ${f.remediation}\n\n` +
        (f.cve ? `**CVE:** ${f.cve}\n` : "") +
        (f.references.length > 0 ? `**References:** ${f.references.join(", ")}\n` : "")
    )
    .join("\n---\n\n");

  const body = `## Security Scan Report

**Scan ID:** \`${report.scanId}\`
**Target:** ${report.target}
**Type:** ${report.scanType}
**Completed:** ${report.completedAt.toISOString()}

## Risk Summary

| Severity | Count |
|----------|-------|
| ğŸ”´ Critical | ${summary.criticalCount} |
| ğŸŸ  High | ${summary.highCount} |
| ğŸŸ¡ Medium | ${summary.mediumCount} |
| ğŸŸ¢ Low | ${summary.lowCount} |
| â„¹ï¸ Info | ${summary.infoCount} |

**Risk Score:** ${summary.riskScore}/100 â€” **${summary.riskRating.toUpperCase()}**

## AI Analysis

${report.aiAnalysis}

## Critical & High Findings

${criticalAndHigh || "_No critical or high findings detected._"}

---
_Generated by DevBot Security Scanner_
`;

  const { data } = await octokit.issues.create({
    owner,
    repo,
    title: `[Security] ${report.scanType} scan â€” ${summary.riskRating.toUpperCase()} risk (score ${summary.riskScore}/100)`,
    body,
    labels: [label, "security", "automated"],
  });

  return data.html_url;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function severityRank(s: Severity): number {
  return { critical: 4, high: 3, medium: 2, low: 1, info: 0 }[s] ?? 0;
}

function extractDomain(target: string): string | null {
  try {
    return new URL(target.startsWith("http") ? target : `https://${target}`).hostname;
  } catch {
    return /^[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$/.test(target) ? target : null;
  }
}

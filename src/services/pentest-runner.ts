/**
 * pentest-runner.ts
 *
 * Safe wrappers around external pentest tools.
 * All execution uses execFileSync with array arguments — NEVER string interpolation.
 * All targets are validated with Zod schemas before passing to any tool.
 *
 * Tools used:
 *  - nmap         : network port/service scanning
 *  - npm audit    : Node.js dependency vulnerability check
 *  - Node dns     : DNS enumeration (built-in, no shell)
 *  - Node https   : HTTP endpoint probing (built-in)
 *  - Regex        : secret/credential scanning (no shell)
 */

import { execFileSync } from "child_process";
import dns from "dns/promises";
import https from "https";
import http from "http";
import fs from "fs/promises";
import path from "path";
import { sanitizeShellArg } from "@/middleware/sanitizer";
import { scanTargetHostSchema, portRangeSchema } from "@/middleware/validators";

// ─────────────────────────────────────────────────────────────────────────────
//  Types
// ─────────────────────────────────────────────────────────────────────────────

export interface PortScanResult {
  host: string;
  openPorts: PortInfo[];
  closedPorts: number[];
  filteredPorts: number[];
  scanDurationMs: number;
  rawOutput: string;
}

export interface PortInfo {
  port: number;
  state: "open" | "filtered";
  service: string;
  version: string;
}

export interface DependencyAuditResult {
  vulnerabilities: DependencyVuln[];
  totalVulns: number;
  criticalCount: number;
  highCount: number;
  moderateCount: number;
  lowCount: number;
  packageManager: "npm" | "pnpm" | "yarn" | "unknown";
  rawOutput: string;
}

export interface DependencyVuln {
  name: string;
  severity: "critical" | "high" | "moderate" | "low" | "info";
  cvss?: number;
  cve?: string;
  description: string;
  fixedIn?: string;
  range: string;
}

export interface SecretScanResult {
  findings: SecretFinding[];
  filesScanned: number;
  totalFindings: number;
}

export interface SecretFinding {
  file: string;
  line: number;
  type: string;
  match: string; // Redacted — first 4 chars + stars
  severity: "critical" | "high" | "medium" | "low";
}

export interface EndpointProbeResult {
  url: string;
  statusCode: number;
  headers: Record<string, string>;
  securityHeaders: SecurityHeaderCheck[];
  tlsInfo?: TLSInfo;
  responseTimeMs: number;
  error?: string;
}

export interface SecurityHeaderCheck {
  header: string;
  present: boolean;
  value?: string;
  recommendation: string;
}

export interface TLSInfo {
  protocol: string;
  cipher: string;
  authorized: boolean;
  expiresAt?: string;
}

export interface DNSEnumResult {
  domain: string;
  records: DNSRecord[];
  subdomains: string[];
}

export interface DNSRecord {
  type: string;
  value: string | string[];
}

// ─────────────────────────────────────────────────────────────────────────────
//  Port Scanner (nmap wrapper)
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Run nmap against a validated host.
 * Uses execFileSync with array args — no shell expansion possible.
 */
export async function runPortScan(
  host: string,
  portRange = "21,22,23,25,53,80,110,143,443,445,3306,3389,5432,5900,6379,8080,8443,27017",
  options: { serviceVersion?: boolean; scripts?: string[] } = {}
): Promise<PortScanResult> {
  // Validate host before touching any tool
  const safeHost = scanTargetHostSchema.parse(host);
  portRangeSchema.parse(portRange);

  const start = Date.now();
  const args = [
    "-oX", "-",          // XML output to stdout
    "-p", portRange,
    "-T4",               // aggressive timing (4/5)
    "--open",            // only show open ports
  ];

  if (options.serviceVersion) {
    args.push("-sV", "--version-intensity", "5");
  }

  if (options.scripts && options.scripts.length > 0) {
    // Validate each script name — alphanumeric + dashes only
    const safeScripts = options.scripts
      .map((s) => s.replace(/[^a-zA-Z0-9\-]/g, ""))
      .filter(Boolean);
    if (safeScripts.length > 0) {
      args.push("--script", safeScripts.join(","));
    }
  }

  args.push(safeHost);

  let rawOutput = "";
  try {
    rawOutput = execFileSync("nmap", args, {
      encoding: "utf-8",
      timeout: 120_000,
      stdio: "pipe",
    });
  } catch (err: any) {
    // nmap exits non-zero on some conditions but still outputs results
    rawOutput = err.stdout ?? "";
    if (!rawOutput.includes("<nmaprun")) {
      throw new Error(`nmap failed: ${err.message}`);
    }
  }

  return parseNmapXML(safeHost, rawOutput, Date.now() - start);
}

/** Parse nmap's XML output into typed results */
function parseNmapXML(host: string, xml: string, durationMs: number): PortScanResult {
  const openPorts: PortInfo[] = [];

  // Extract open ports from nmap XML
  const portMatches = xml.matchAll(
    /<port protocol="[^"]+" portid="(\d+)">[^]*?<state state="(open|filtered)"[^]*?<service name="([^"]*)"(?:[^>]*version="([^"]*)")?/g
  );

  for (const m of portMatches) {
    openPorts.push({
      port: parseInt(m[1], 10),
      state: m[2] as "open" | "filtered",
      service: m[3] ?? "unknown",
      version: m[4] ?? "",
    });
  }

  return {
    host,
    openPorts,
    closedPorts: [],
    filteredPorts: [],
    scanDurationMs: durationMs,
    rawOutput: xml.slice(0, 4000), // Don't store the full multi-MB XML
  };
}

// ─────────────────────────────────────────────────────────────────────────────
//  Dependency Auditor
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Run npm/pnpm audit on a project directory.
 * Detects which package manager is in use.
 */
export async function auditDependencies(repoPath: string): Promise<DependencyAuditResult> {
  // Validate path doesn't escape workspace
  const resolved = path.resolve(repoPath);
  if (resolved.includes("..")) throw new Error("Invalid repo path");

  // Detect package manager
  const [hasNpm, hasPnpm, hasYarn] = await Promise.all([
    fs.access(path.join(resolved, "package-lock.json")).then(() => true).catch(() => false),
    fs.access(path.join(resolved, "pnpm-lock.yaml")).then(() => true).catch(() => false),
    fs.access(path.join(resolved, "yarn.lock")).then(() => true).catch(() => false),
  ]);

  let pm: DependencyAuditResult["packageManager"] = "unknown";
  let cmd = "npm";
  let args = ["audit", "--json"];

  if (hasPnpm) { pm = "pnpm"; cmd = "pnpm"; args = ["audit", "--json"]; }
  else if (hasNpm) { pm = "npm"; }
  else if (hasYarn) { pm = "yarn"; cmd = "yarn"; args = ["audit", "--json"]; }

  let rawOutput = "";
  try {
    rawOutput = execFileSync(cmd, args, {
      cwd: resolved,
      encoding: "utf-8",
      timeout: 60_000,
      stdio: "pipe",
    });
  } catch (err: any) {
    // npm audit exits 1 when vulnerabilities found — capture output anyway
    rawOutput = err.stdout ?? "{}";
  }

  return parseAuditOutput(rawOutput, pm);
}

function parseAuditOutput(
  raw: string,
  pm: DependencyAuditResult["packageManager"]
): DependencyAuditResult {
  const vulnerabilities: DependencyVuln[] = [];
  let critical = 0, high = 0, moderate = 0, low = 0;

  try {
    const json = JSON.parse(raw);

    // npm/pnpm audit v7+ format
    const vulns = json.vulnerabilities ?? json.advisories ?? {};
    for (const [name, vuln] of Object.entries(vulns as Record<string, any>)) {
      const sev = (vuln.severity ?? vuln.via?.[0]?.severity ?? "low") as DependencyVuln["severity"];
      const entry: DependencyVuln = {
        name: name ?? vuln.name,
        severity: sev,
        cvss: vuln.cvss?.score,
        cve: Array.isArray(vuln.cves) ? vuln.cves[0] : undefined,
        description: vuln.overview ?? vuln.via?.[0]?.title ?? "No description",
        fixedIn: vuln.fixAvailable?.version,
        range: vuln.range ?? vuln.via?.[0]?.range ?? "*",
      };
      vulnerabilities.push(entry);
      if (sev === "critical") critical++;
      else if (sev === "high") high++;
      else if (sev === "moderate") moderate++;
      else low++;
    }
  } catch {
    // Unparseable output — return empty with raw
  }

  return {
    vulnerabilities,
    totalVulns: vulnerabilities.length,
    criticalCount: critical,
    highCount: high,
    moderateCount: moderate,
    lowCount: low,
    packageManager: pm,
    rawOutput: raw.slice(0, 5000),
  };
}

// ─────────────────────────────────────────────────────────────────────────────
//  Secret Scanner (regex-based, no shell)
// ─────────────────────────────────────────────────────────────────────────────

const SECRET_PATTERNS: Array<{ type: string; pattern: RegExp; severity: SecretFinding["severity"] }> = [
  { type: "AWS Access Key",      pattern: /AKIA[0-9A-Z]{16}/g,                                         severity: "critical" },
  { type: "AWS Secret Key",      pattern: /(?<![A-Za-z0-9/+])[A-Za-z0-9/+]{40}(?![A-Za-z0-9/+])/g,   severity: "critical" },
  { type: "GitHub Token (PAT)",  pattern: /ghp_[a-zA-Z0-9]{36}/g,                                     severity: "critical" },
  { type: "GitHub Token (OAuth)",pattern: /gho_[a-zA-Z0-9]{36}/g,                                     severity: "critical" },
  { type: "GitHub App Token",    pattern: /ghs_[a-zA-Z0-9]{36}/g,                                     severity: "critical" },
  { type: "Stripe Secret Key",   pattern: /sk_live_[0-9a-zA-Z]{24,}/g,                               severity: "critical" },
  { type: "Stripe Pub Key",      pattern: /pk_live_[0-9a-zA-Z]{24,}/g,                               severity: "high" },
  { type: "Anthropic API Key",   pattern: /sk-ant-[a-zA-Z0-9\-_]{32,}/g,                             severity: "critical" },
  { type: "OpenAI API Key",      pattern: /sk-[a-zA-Z0-9]{48,}/g,                                    severity: "critical" },
  { type: "Slack Bot Token",     pattern: /xoxb-[0-9]{10,12}-[0-9]{10,12}-[a-zA-Z0-9]{24}/g,        severity: "critical" },
  { type: "Slack App Token",     pattern: /xapp-[0-9]-[A-Z0-9]{10,12}-[0-9]{13}-[a-z0-9]{64}/g,    severity: "critical" },
  { type: "Private RSA Key",     pattern: /-----BEGIN (?:RSA |EC )?PRIVATE KEY-----/g,               severity: "critical" },
  { type: "Private Key (PKCS8)", pattern: /-----BEGIN PRIVATE KEY-----/g,                            severity: "critical" },
  { type: "Generic Password",    pattern: /(?:password|passwd|pwd)\s*[:=]\s*["']?[^\s"']{8,}["']?/gi, severity: "high" },
  { type: "Generic Secret",      pattern: /(?:secret|api_secret|client_secret)\s*[:=]\s*["']?[a-zA-Z0-9+/]{16,}["']?/gi, severity: "high" },
  { type: "Connection String",   pattern: /(?:mongodb|postgres|mysql|redis):\/\/[^:]+:[^@]+@/gi,      severity: "high" },
  { type: "JWT Token",           pattern: /eyJ[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}/g, severity: "medium" },
  { type: "Bearer Token",        pattern: /Bearer\s+[a-zA-Z0-9\-_.~+/]{20,}/g,                       severity: "medium" },
];

const SKIP_EXTENSIONS = new Set([
  ".jpg", ".jpeg", ".png", ".gif", ".mp4", ".mp3", ".wav", ".pdf",
  ".zip", ".tar", ".gz", ".bin", ".lock", ".svg", ".ico",
]);

const SKIP_DIRS = new Set([
  "node_modules", ".git", "dist", "build", ".next", ".vite", "coverage",
  "__pycache__", ".pytest_cache",
]);

/**
 * Recursively scan a directory for leaked secrets.
 */
export async function scanForSecrets(
  dirPath: string,
  maxFileSizeBytes = 500_000
): Promise<SecretScanResult> {
  const findings: SecretFinding[] = [];
  let filesScanned = 0;

  async function walk(dir: string): Promise<void> {
    let entries: import("fs").Dirent<string>[];
    try {
      entries = await fs.readdir(dir, { withFileTypes: true, encoding: "utf-8" });
    } catch {
      return;
    }

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        if (!SKIP_DIRS.has(entry.name)) await walk(fullPath);
        continue;
      }

      if (!entry.isFile()) continue;
      const ext = path.extname(entry.name).toLowerCase();
      if (SKIP_EXTENSIONS.has(ext)) continue;

      // Skip large files
      try {
        const stat = await fs.stat(fullPath);
        if (stat.size > maxFileSizeBytes) continue;
      } catch {
        continue;
      }

      let content: string;
      try {
        content = await fs.readFile(fullPath, "utf-8");
      } catch {
        continue;
      }

      filesScanned++;
      const lines = content.split("\n");

      for (const { type, pattern, severity } of SECRET_PATTERNS) {
        pattern.lastIndex = 0; // reset global regex state
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          let match: RegExpExecArray | null;
          pattern.lastIndex = 0;
          while ((match = pattern.exec(line)) !== null) {
            const raw = match[0];
            // Redact: keep first 4 chars + "****"
            const redacted = raw.slice(0, 4) + "****";
            const relPath = path.relative(dirPath, fullPath);
            findings.push({
              file: relPath,
              line: i + 1,
              type,
              match: redacted,
              severity,
            });
          }
        }
      }
    }
  }

  await walk(path.resolve(dirPath));

  return { findings, filesScanned, totalFindings: findings.length };
}

// ─────────────────────────────────────────────────────────────────────────────
//  HTTP Endpoint Prober
// ─────────────────────────────────────────────────────────────────────────────

const SECURITY_HEADERS = [
  { header: "Strict-Transport-Security",  recommendation: "Add HSTS: max-age=31536000; includeSubDomains" },
  { header: "Content-Security-Policy",    recommendation: "Add CSP to prevent XSS and data injection" },
  { header: "X-Content-Type-Options",     recommendation: "Add: X-Content-Type-Options: nosniff" },
  { header: "X-Frame-Options",            recommendation: "Add: X-Frame-Options: DENY or SAMEORIGIN" },
  { header: "Referrer-Policy",            recommendation: "Add: Referrer-Policy: strict-origin-when-cross-origin" },
  { header: "Permissions-Policy",         recommendation: "Add Permissions-Policy to restrict browser features" },
  { header: "X-XSS-Protection",          recommendation: "Add: X-XSS-Protection: 1; mode=block (legacy browsers)" },
  { header: "Cache-Control",              recommendation: "Ensure sensitive endpoints set Cache-Control: no-store" },
];

export async function probeEndpoint(url: string, timeoutMs = 10_000): Promise<EndpointProbeResult> {
  const start = Date.now();
  const parsed = new URL(url);
  const isHttps = parsed.protocol === "https:";
  const lib = isHttps ? https : http;

  return new Promise((resolve) => {
    const req = lib.request(
      url,
      {
        method: "GET",
        timeout: timeoutMs,
        headers: {
          "User-Agent": "DevBot-SecurityScanner/1.0",
          Accept: "*/*",
        },
        rejectUnauthorized: false, // We want to detect bad certs, not abort
      },
      (res) => {
        const headers: Record<string, string> = {};
        for (const [k, v] of Object.entries(res.headers)) {
          headers[k] = Array.isArray(v) ? v.join(", ") : (v ?? "");
        }

        const securityHeaders: SecurityHeaderCheck[] = SECURITY_HEADERS.map(({ header, recommendation }) => ({
          header,
          present: header.toLowerCase() in res.headers,
          value: headers[header.toLowerCase()],
          recommendation,
        }));

        const tlsInfo: TLSInfo | undefined = isHttps
          ? extractTLSInfo(res.socket as any)
          : undefined;

        // Drain body to free socket
        res.resume();
        res.on("end", () => {
          resolve({
            url,
            statusCode: res.statusCode ?? 0,
            headers,
            securityHeaders,
            tlsInfo,
            responseTimeMs: Date.now() - start,
          });
        });
      }
    );

    req.on("timeout", () => {
      req.destroy();
      resolve({
        url,
        statusCode: 0,
        headers: {},
        securityHeaders: [],
        responseTimeMs: Date.now() - start,
        error: "Request timed out",
      });
    });

    req.on("error", (err) => {
      resolve({
        url,
        statusCode: 0,
        headers: {},
        securityHeaders: [],
        responseTimeMs: Date.now() - start,
        error: err.message,
      });
    });

    req.end();
  });
}

function extractTLSInfo(socket: any): TLSInfo {
  try {
    const cipher = socket.getCipher?.() ?? {};
    const cert = socket.getPeerCertificate?.() ?? {};
    return {
      protocol: socket.getProtocol?.() ?? "unknown",
      cipher: cipher.name ?? "unknown",
      authorized: socket.authorized ?? false,
      expiresAt: cert.valid_to,
    };
  } catch {
    return { protocol: "unknown", cipher: "unknown", authorized: false };
  }
}

// ─────────────────────────────────────────────────────────────────────────────
//  DNS Enumerator (Node built-in)
// ─────────────────────────────────────────────────────────────────────────────

const COMMON_SUBDOMAINS = [
  "www", "api", "admin", "mail", "smtp", "ftp", "ssh", "dev", "staging",
  "test", "beta", "app", "dashboard", "portal", "static", "cdn", "media",
  "uploads", "assets", "auth", "login", "signup", "docs", "status", "vpn",
];

export async function enumerateDNS(domain: string): Promise<DNSEnumResult> {
  // Sanitize: alphanumeric + dots + dashes only
  const safeDomain = domain.replace(/[^a-zA-Z0-9.\-]/g, "").toLowerCase();
  if (!safeDomain || safeDomain.length > 253) throw new Error("Invalid domain");

  const records: DNSRecord[] = [];
  const subdomains: string[] = [];

  // Standard records
  const recordTypes: Array<{ type: string; fn: () => Promise<any> }> = [
    { type: "A",    fn: () => dns.resolve4(safeDomain).catch(() => []) },
    { type: "AAAA", fn: () => dns.resolve6(safeDomain).catch(() => []) },
    { type: "MX",   fn: () => dns.resolveMx(safeDomain).then((r) => r.map((m) => m.exchange)).catch(() => []) },
    { type: "TXT",  fn: () => dns.resolveTxt(safeDomain).then((r) => r.map((t) => t.join(""))).catch(() => []) },
    { type: "NS",   fn: () => dns.resolveNs(safeDomain).catch(() => []) },
    { type: "SOA",  fn: () => dns.resolveSoa(safeDomain).then((s) => [s.nsname]).catch(() => []) },
  ];

  for (const { type, fn } of recordTypes) {
    const values = await fn();
    if (values.length > 0) records.push({ type, value: values });
  }

  // Subdomain brute-force (limited, no external tool)
  const subChecks = await Promise.allSettled(
    COMMON_SUBDOMAINS.map(async (sub) => {
      const fqdn = `${sub}.${safeDomain}`;
      const addrs = await dns.resolve4(fqdn).catch(() => null);
      if (addrs && addrs.length > 0) return fqdn;
      return null;
    })
  );

  for (const result of subChecks) {
    if (result.status === "fulfilled" && result.value) {
      subdomains.push(result.value);
    }
  }

  return { domain: safeDomain, records, subdomains };
}

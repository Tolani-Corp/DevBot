
import {
  formatJwtAttack,
  formatJwtDefense,
  formatScraperPattern,
  formatDefensePlaybook,
  formatROETemplate,
  formatAuthBypassTechnique,
  buildMissionGuidanceText,
  identifyHashLocal,
  scanContentLocal,
  formatVpnProtocol,
  formatVpnLeak,
  formatVpnDefense,
  formatVpnProvider,
  DEFAULT_CREDS,
  formatPasswordAttackTechnique,
} from "../formatters.js";


import {
  ROE_TEMPLATES,
  PASSWORD_ATTACK_TECHNIQUES,
  AUTH_BYPASS_TECHNIQUES,
  MISSION_CHECKLISTS,
  REVERSE_ENGINEERING_KNOWLEDGE,
  type ROETemplate,
  type PasswordAttackTechnique,
  type AuthBypassTechnique,
  type ReverseEngineeringKnowledge,
} from "../knowledge.js";

import { generatePassword, generatePassphrase } from "../password-generator.js";

import {
  VULNERABILITY_CLASSES,
  BUG_BOUNTY_METHODOLOGY,
  DEVSECOPS_PIPELINE_STAGES,
  PENTEST_METHODOLOGY,
  DAST_SCAN_PROFILES,
  COMPLIANCE_FRAMEWORKS,
  getVulnByCategory,
  getVulnBySeverity,
  getVulnById,
  getComplianceFramework,
  getDASTProfile,
  type VulnerabilityClass,
  type WebSecurityCategory,
} from "../portswigger.js";

import {
  SCRAPER_PATTERNS,
  DEFENSE_PLAYBOOKS,
  PLATFORM_DEFENSE_PROFILES,
  CONTENT_INTEGRITY_CHECKS,
  getScraperPattern,
  getScrapersByTechnique,
  getScrapersBySeverity,
  getDefensePlaybook,
  getDefensesByCategory,
  getDefensesForTechnique,
  getPlatformProfile,
  getContentIntegrityCheck,
  getAllTestCases,
  getAutomatableTests,
  scoreDefensePosture,
  type ScraperTechnique,
  type DefenseCategory,
} from "../media-security.js";

import {
  JWT_ATTACK_PATTERNS,
  JWT_DEFENSE_PLAYBOOKS,
  JWT_LIBRARY_VULNS,
  decodeJwt,
  analyzeJwtConfig,
  getJwtAttack,
  getJwtAttacksByType,
  getJwtAttacksBySeverity,
  getAutomatableJwtAttacks,
  getJwtDefense,
  getJwtDefensesByCategory,
  getJwtDefensesForAttack,
  getAllJwtTestCases,
  getJwtLibraryVulnsByLanguage,
  getJwtLibraryVulnsBySeverity,
  scoreJwtPosture,
  type JwtAttackType,
  type JwtDefenseCategory,
  type JwtSeverity,
  type JwtAttackPattern,
  type JwtDefensePlaybook,
} from "../jwt-security.js";

import {
  VPN_PROTOCOL_ANALYSIS,
  VPN_LEAK_PATTERNS,
  VPN_DEFENSE_PLAYBOOKS,
  VPN_PROVIDER_PROFILES,
  analyzeVpnConfig,
  analyzeIpReputation,
  buildOperationalConfig,
  getVpnProtocol,
  getSecureProtocols,
  getVpnLeak,
  getVpnLeaksByType,
  getVpnLeaksBySeverity,
  getAutomatableVpnLeakTests,
  getVpnDefense,
  getVpnDefensesByCategory,
  getVpnDefensesForLeak,
  getVpnProvider,
  getVpnProvidersWithApi,
  getVpnProvidersByProtocol,
  getNoLogVpnProviders,
  getAllVpnTestCases,
  getAutomatableVpnTests,
  scoreVpnPosture,
  type VpnProtocol,
  type VpnLeakType,
  type VpnDefenseCategory,
  type VpnProvider,
  type VpnSeverity,
  type VpnLeakPattern,
  type VpnDefensePlaybook as VpnDefensePlaybookType,
  type VpnProviderProfile,
} from "../vpn-security.js";

export async function handle(args: any) {
{
        const id = args?.["id"] as string | undefined;
        const category = args?.["category"] as WebSecurityCategory | undefined;
        const severity = args?.["severity"] as VulnerabilityClass["severity"] | undefined;
        const listAll = args?.["list_all"] as boolean | undefined;

        if (listAll) {
          const summary = VULNERABILITY_CLASSES.map(
            (v) => `${v.id} | ${v.name} | ${v.severity} | ${v.category} | ${v.owaspTopTen}`
          );
          return {
            content: [{
              type: "text",
              text: `# Vulnerability Classes (${summary.length} total)\n\nID | Name | Severity | Category | OWASP\n---|------|----------|----------|------\n${summary.join("\n")}`,
            }],
          };
        }

        let vulns: VulnerabilityClass[];
        if (id) {
          const v = getVulnById(id);
          vulns = v ? [v] : [];
        } else if (category) {
          vulns = getVulnByCategory(category);
        } else if (severity) {
          vulns = getVulnBySeverity(severity);
        } else {
          vulns = VULNERABILITY_CLASSES;
        }

        if (vulns.length === 0) {
          return { content: [{ type: "text", text: "No vulnerabilities found matching the criteria." }] };
        }

        const text = vulns.map((v) => [
          `# [${v.severity.toUpperCase()}] ${v.name}`,
          `**ID:** ${v.id} | **Category:** ${v.category} | **CWEs:** ${v.cwes.join(", ")}`,
          `**OWASP:** ${v.owaspTopTen}`,
          ``,
          `## Description`,
          v.description,
          ``,
          `## Impact`,
          v.impact,
          ``,
          `## Detection Methods`,
          v.detectionMethods.map((d) => `- ${d}`).join("\n"),
          ``,
          `## Test Cases`,
          ...v.testCases.map((tc) => [
            `### ${tc.name} ${tc.automatable ? "âš™ï¸" : "ðŸ”§"}`,
            `**Technique:** ${tc.technique}`,
            ...(tc.payloads ? [`**Payloads:**\n\`\`\`\n${tc.payloads.join("\n")}\n\`\`\``] : []),
            `**Indicators:** ${tc.indicators.join("; ")}`,
          ].join("\n")),
          ``,
          `## Remediation`,
          v.remediation.map((r) => `- ${r}`).join("\n"),
          ``,
          `## References`,
          v.references.map((r) => `- ${r}`).join("\n"),
        ].join("\n")).join("\n\n---\n\n");

        return { content: [{ type: "text", text }] };
      }
}
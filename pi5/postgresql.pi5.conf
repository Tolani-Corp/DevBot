# ─── PostgreSQL 16 — Raspberry Pi 5 Optimized Settings ────────────────────────
# Append these to /etc/postgresql/16/main/postgresql.conf
# OR include via: include_if_exists '/etc/postgresql/pi5.conf'
#
# Tuned for: BCM2712 / Cortex-A76 quad-core, 16GB LPDDR4X
#            NVMe SSD storage (/mnt/nvme/docker/postgres)
#            Workload: DevBot task history, NATT mission vault, analytics

# ── Connection settings ─────────────────────────────────────────────────────────
max_connections = 100            # DevBot + worker + cron: ~15 connections typical
superuser_reserved_connections = 3

# ── Memory ─────────────────────────────────────────────────────────────────────
# Target: 2GB allocated to PostgreSQL on 16GB board
# (Node.js: 4GB, Redis: 512MB, OS: ~2GB, rest: headroom)
shared_buffers = 2GB             # 25% of available Pi RAM — aggressive for PG
effective_cache_size = 6GB       # Planner hint — total RAM free for caching
work_mem = 64MB                  # Per-sort/hash operation (100 connections × 64MB peak)
maintenance_work_mem = 256MB     # VACUUM, CREATE INDEX
wal_buffers = 64MB               # Auto-tuned from shared_buffers

# ── NVMe storage tuning ─────────────────────────────────────────────────────────
data_directory = '/mnt/nvme/docker/postgres'
wal_level = replica
wal_compression = zstd           # Compress WAL (NVMe has bandwidth; save space)
max_wal_size = 2GB
min_wal_size = 256MB
checkpoint_completion_target = 0.9
checkpoint_timeout = 10min

# NVMe random I/O settings
random_page_cost = 1.1           # NVMe random cost ≈ sequential (vs 4.0 for HDD)
seq_page_cost = 1.0
effective_io_concurrency = 64    # NVMe can handle many concurrent I/O requests
maintenance_io_concurrency = 32

# ── Parallelism (Cortex-A76 quad-core) ─────────────────────────────────────────
max_parallel_workers_per_gather = 2
max_parallel_maintenance_workers = 2
max_parallel_workers = 4
parallel_setup_cost = 500
parallel_tuple_cost = 0.05

# ── Connection performance ─────────────────────────────────────────────────────
# DevBot uses postgres.js (connection pool) — persistent connections are fine
tcp_keepalives_idle = 60
tcp_keepalives_interval = 10
tcp_keepalives_count = 6

# ── Query planner ──────────────────────────────────────────────────────────────
enable_partitionwise_join = on
enable_partitionwise_aggregate = on
enable_async_append = on
jit = on                         # JIT compilation — beneficial for analytics queries

# ── Autovacuum (aggressive — NATT vault gets frequent inserts) ──────────────────
autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 30s
autovacuum_vacuum_scale_factor = 0.05
autovacuum_analyze_scale_factor = 0.025
autovacuum_vacuum_cost_limit = 800
vacuum_cost_delay = 2ms

# ── Logging ────────────────────────────────────────────────────────────────────
logging_collector = on
log_directory = '/mnt/nvme/logs/devbot'
log_filename = 'postgresql-%a.log'
log_rotation_age = 1d
log_rotation_size = 100MB
log_min_duration_statement = 1000   # Log queries > 1 second
log_checkpoints = on
log_connections = off
log_disconnections = off
log_lock_waits = on
log_temp_files = 16MB
log_timezone = 'UTC'

# ── Security ────────────────────────────────────────────────────────────────────
listen_addresses = 'localhost'       # Loopback only
ssl = off                            # SSL handled by Caddy proxy layer
password_encryption = scram-sha-256

# ── Stats ───────────────────────────────────────────────────────────────────────
track_activities = on
track_counts = on
track_io_timing = on               # Useful for diagnosing slow I/O on NVMe
track_functions = pl

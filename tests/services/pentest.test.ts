import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import os from "os";
import fs from "fs/promises";
import path from "path";

// â”€â”€â”€ Mock external dependencies before importing modules â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

vi.mock("@anthropic-ai/sdk", () => ({
  default: vi.fn().mockImplementation(() => ({
    messages: {
      create: vi.fn().mockResolvedValue({
        content: [{ type: "text", text: "## AI Analysis\n1. Fix critical deps\n2. Rotate secrets" }],
      }),
    },
  })),
}));

vi.mock("@octokit/rest", () => ({
  Octokit: vi.fn().mockImplementation(() => ({
    issues: {
      create: vi.fn().mockResolvedValue({ data: { html_url: "https://github.com/org/repo/issues/99" } }),
    },
  })),
}));

// Mock nmap so port scan tests don't require the binary
vi.mock("child_process", async (importOriginal) => {
  const original = await importOriginal<typeof import("child_process")>();
  return {
    ...original,
    execFileSync: vi.fn().mockImplementation((cmd: string, args: string[]) => {
      if (cmd === "nmap") {
        return MOCK_NMAP_XML;
      }
      if (cmd === "npm" && args.includes("audit")) {
        return JSON.stringify(MOCK_NPM_AUDIT);
      }
      if (cmd === "pnpm" && args.includes("audit")) {
        return JSON.stringify(MOCK_NPM_AUDIT);
      }
      return "";
    }),
  };
});

import {
  scanTargetUrlSchema,
  scanTargetHostSchema,
  portRangeSchema,
  pentestScanSchema,
  validateScanTarget,
  validatePentestScan,
} from "@/middleware/validators";
import {
  scanForSecrets,
  probeEndpoint,
  enumerateDNS,
  type SecretFinding,
} from "@/services/pentest-runner";
import {
  runPentestScan,
  formatReportForSlack,
  postReportAsGitHubIssue,
  type PentestReport,
} from "@/services/pentest";

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Fixtures
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const MOCK_NMAP_XML = `
<nmaprun>
  <host>
    <ports>
      <port protocol="tcp" portid="22">
        <state state="open" reason="syn-ack"/>
        <service name="ssh" version="OpenSSH 8.9"/>
      </port>
      <port protocol="tcp" portid="443">
        <state state="open" reason="syn-ack"/>
        <service name="https" version="nginx 1.24"/>
      </port>
      <port protocol="tcp" portid="3306">
        <state state="open" reason="syn-ack"/>
        <service name="mysql" version="8.0.32"/>
      </port>
    </ports>
  </host>
</nmaprun>`;

const MOCK_NPM_AUDIT = {
  vulnerabilities: {
    lodash: {
      name: "lodash",
      severity: "high",
      overview: "Prototype pollution in lodash",
      range: "<4.17.21",
      fixAvailable: { version: "4.17.21" },
      cvss: { score: 7.4 },
      cves: ["CVE-2021-23337"],
    },
    minimist: {
      name: "minimist",
      severity: "critical",
      overview: "Prototype pollution in minimist",
      range: "<1.2.6",
      fixAvailable: { version: "1.2.6" },
      cvss: { score: 9.8 },
      cves: ["CVE-2021-44906"],
    },
  },
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Validator Tests
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

describe("scanTargetUrlSchema", () => {
  it("accepts valid https URL", () => {
    expect(scanTargetUrlSchema.safeParse("https://freakme.fun").success).toBe(true);
  });

  it("accepts valid http URL", () => {
    expect(scanTargetUrlSchema.safeParse("http://freakme.fun").success).toBe(true);
  });

  it("rejects localhost URL", () => {
    expect(scanTargetUrlSchema.safeParse("http://localhost:3000").success).toBe(false);
  });

  it("rejects 127.0.0.1", () => {
    expect(scanTargetUrlSchema.safeParse("http://127.0.0.1:80").success).toBe(false);
  });

  it("rejects 192.168.x.x (internal)", () => {
    expect(scanTargetUrlSchema.safeParse("http://192.168.1.100").success).toBe(false);
  });

  it("rejects non-URL string", () => {
    expect(scanTargetUrlSchema.safeParse("not a url").success).toBe(false);
  });

  it("rejects ftp:// scheme", () => {
    expect(scanTargetUrlSchema.safeParse("ftp://freakme.fun").success).toBe(false);
  });
});

describe("scanTargetHostSchema", () => {
  it("accepts valid hostname", () => {
    expect(scanTargetHostSchema.safeParse("freakme.fun").success).toBe(true);
  });

  it("accepts valid IP", () => {
    expect(scanTargetHostSchema.safeParse("203.0.113.5").success).toBe(true);
  });

  it("rejects localhost", () => {
    expect(scanTargetHostSchema.safeParse("localhost").success).toBe(false);
  });

  it("rejects internal subnet IP", () => {
    expect(scanTargetHostSchema.safeParse("10.0.0.1").success).toBe(false);
  });

  it("rejects shell injection attempt", () => {
    // Regex should reject semicolons and spaces
    expect(scanTargetHostSchema.safeParse("example.com; rm -rf /").success).toBe(false);
  });
});

describe("portRangeSchema", () => {
  it("accepts single port", () => {
    expect(portRangeSchema.safeParse("80").success).toBe(true);
  });

  it("accepts comma-separated ports", () => {
    expect(portRangeSchema.safeParse("80,443,8080").success).toBe(true);
  });

  it("accepts range", () => {
    expect(portRangeSchema.safeParse("1-1000").success).toBe(true);
  });

  it("rejects port 0", () => {
    expect(portRangeSchema.safeParse("0").success).toBe(false);
  });

  it("rejects port over 65535", () => {
    expect(portRangeSchema.safeParse("65536").success).toBe(false);
  });

  it("rejects shell injection", () => {
    expect(portRangeSchema.safeParse("80; rm -rf /").success).toBe(false);
  });
});

describe("pentestScanSchema", () => {
  it("accepts valid scan request", () => {
    const result = pentestScanSchema.safeParse({
      target: "freakme.fun",
      scanType: "web-security",
      authorized: true,
    });
    expect(result.success).toBe(true);
  });

  it("rejects when authorized is false", () => {
    const result = pentestScanSchema.safeParse({
      target: "freakme.fun",
      scanType: "web-security",
      authorized: false,
    });
    expect(result.success).toBe(false);
  });

  it("rejects invalid scan type", () => {
    const result = pentestScanSchema.safeParse({
      target: "freakme.fun",
      scanType: "sql-injection",
      authorized: true,
    });
    expect(result.success).toBe(false);
  });

  it("rejects repository without owner/repo format", () => {
    const result = pentestScanSchema.safeParse({
      target: "freakme.fun",
      scanType: "dependency-audit",
      authorized: true,
      repository: "just-a-name",
    });
    expect(result.success).toBe(false);
  });

  it("accepts repository in owner/repo format", () => {
    const result = pentestScanSchema.safeParse({
      target: "freakme.fun",
      scanType: "dependency-audit",
      authorized: true,
      repository: "Tolani-Corp/freakme.fun",
    });
    expect(result.success).toBe(true);
  });
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Secret Scanner Tests
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

describe("scanForSecrets", () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "pentest-test-"));
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  it("detects hardcoded Stripe secret key", async () => {
    await fs.writeFile(
      path.join(tmpDir, "config.js"),
      `const stripe = require('stripe');\nconst sk = 'sk_live_abc123DEF456ghi789JKL012';\n`
    );
    const result = await scanForSecrets(tmpDir);
    expect(result.totalFindings).toBeGreaterThan(0);
    const found = result.findings.find((f) => f.type === "Stripe Secret Key");
    expect(found).toBeDefined();
    expect(found!.severity).toBe("critical");
  });

  it("detects AWS access key", async () => {
    await fs.writeFile(
      path.join(tmpDir, "aws.ts"),
      `const ACCESS_KEY = 'AKIAIOSFODNN7EXAMPLE';\n`
    );
    const result = await scanForSecrets(tmpDir);
    const found = result.findings.find((f) => f.type === "AWS Access Key");
    expect(found).toBeDefined();
  });

  it("detects GitHub PAT token", async () => {
    await fs.writeFile(
      path.join(tmpDir, "deploy.sh"),
      `TOKEN=ghp_abcdefghijklmnopqrstuvwxyz123456789A\n`
    );
    const result = await scanForSecrets(tmpDir);
    const found = result.findings.find((f) => f.type === "GitHub Token (PAT)");
    expect(found).toBeDefined();
    expect(found!.severity).toBe("critical");
  });

  it("detects Anthropic API key", async () => {
    await fs.writeFile(
      path.join(tmpDir, "ai.ts"),
      `const key = 'sk-ant-api03-abcdefghijk1234567890abcdefghijk1234';\n`
    );
    const result = await scanForSecrets(tmpDir);
    const found = result.findings.find((f) => f.type === "Anthropic API Key");
    expect(found).toBeDefined();
  });

  it("detects database connection string", async () => {
    await fs.writeFile(
      path.join(tmpDir, "db.ts"),
      `const url = 'postgres://admin:SuperSecret123@db.freakme.fun:5432/prod';\n`
    );
    const result = await scanForSecrets(tmpDir);
    const found = result.findings.find((f) => f.type === "Connection String");
    expect(found).toBeDefined();
    expect(found!.severity).toBe("high");
  });

  it("redacts matched values in findings", async () => {
    await fs.writeFile(
      path.join(tmpDir, "config.js"),
      `const sk = 'sk_live_abc123DEF456ghi789JKL012';\n`
    );
    const result = await scanForSecrets(tmpDir);
    for (const f of result.findings) {
      // Should never expose full secret â€” max 4 chars then stars
      expect(f.match.length).toBeLessThan(20);
      expect(f.match).toMatch(/\*{4}$/);
    }
  });

  it("skips node_modules directory", async () => {
    const nmDir = path.join(tmpDir, "node_modules", "some-pkg");
    await fs.mkdir(nmDir, { recursive: true });
    await fs.writeFile(
      path.join(nmDir, "index.js"),
      `const sk = 'sk_live_abc123DEF456ghi789JKL012';\n`
    );
    const result = await scanForSecrets(tmpDir);
    const nmHit = result.findings.find((f) => f.file.includes("node_modules"));
    expect(nmHit).toBeUndefined();
  });

  it("returns zero findings for clean code", async () => {
    await fs.writeFile(
      path.join(tmpDir, "clean.ts"),
      `export function add(a: number, b: number): number { return a + b; }\n`
    );
    const result = await scanForSecrets(tmpDir);
    expect(result.totalFindings).toBe(0);
    expect(result.filesScanned).toBe(1);
  });

  it("records correct file and line number", async () => {
    await fs.writeFile(
      path.join(tmpDir, "app.ts"),
      `const a = 1;\nconst b = 2;\nconst key = 'AKIAIOSFODNN7EXAMPLE';\n`
    );
    const result = await scanForSecrets(tmpDir);
    const finding = result.findings.find((f) => f.type === "AWS Access Key");
    expect(finding!.line).toBe(3);
    expect(finding!.file).toBe("app.ts");
  });
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Pentest Service Tests
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

describe("runPentestScan â€” authorization gate", () => {
  it("throws when authorized is false", async () => {
    await expect(
      runPentestScan("freakme.fun", "web-security", { authorized: false })
    ).rejects.toThrow();
  });
});

describe("runPentestScan â€” dependency audit", () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "pentest-dep-"));
    // Create a minimal package-lock.json to trigger npm audit
    await fs.writeFile(path.join(tmpDir, "package-lock.json"), "{}");
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  it("returns a PentestReport with findings from mocked npm audit", async () => {
    const report = await runPentestScan("freakme.fun", "dependency-audit", {
      authorized: true,
      repoPath: tmpDir,
    });

    expect(report.scanId).toMatch(/^scan-/);
    expect(report.scanType).toBe("dependency-audit");
    expect(report.target).toBe("freakme.fun");
    expect(report.completedAt.getTime()).toBeGreaterThanOrEqual(report.startedAt.getTime());
  });

  it("builds correct severity summary", async () => {
    const report = await runPentestScan("freakme.fun", "dependency-audit", {
      authorized: true,
      repoPath: tmpDir,
    });

    // Mocked audit has 1 critical + 1 high
    expect(report.summary.criticalCount + report.summary.highCount).toBeGreaterThan(0);
    expect(report.summary.riskScore).toBeGreaterThan(0);
  });

  it("includes AI analysis string", async () => {
    const report = await runPentestScan("freakme.fun", "dependency-audit", {
      authorized: true,
      repoPath: tmpDir,
    });
    expect(typeof report.aiAnalysis).toBe("string");
    expect(report.aiAnalysis.length).toBeGreaterThan(0);
  });
});

describe("runPentestScan â€” secret scan", () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "pentest-secret-"));
    await fs.writeFile(
      path.join(tmpDir, "config.ts"),
      `const sk = 'sk_live_superrealstripekey123456789ABC';\n`
    );
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  it("finds leaked Stripe key and maps to critical finding", async () => {
    const report = await runPentestScan("freakme.fun", "secret-scan", {
      authorized: true,
      repoPath: tmpDir,
    });

    const stripe = report.findings.find((f) => f.category === "Exposed Secret / Credential");
    expect(stripe).toBeDefined();
    expect(stripe!.severity).toBe("critical");
  });
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Report Formatter Tests
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

describe("formatReportForSlack", () => {
  const mockReport: PentestReport = {
    scanId: "scan-test-001",
    target: "freakme.fun",
    scanType: "full",
    startedAt: new Date("2026-02-22T12:00:00Z"),
    completedAt: new Date("2026-02-22T12:05:00Z"),
    findings: [
      {
        id: "dep-0",
        severity: "critical",
        category: "Vulnerable Dependency",
        title: "CRITICAL: lodash prototype pollution",
        description: "Prototype pollution allows arbitrary object modification",
        evidence: "Package: lodash\nRange: <4.17.21",
        cve: "CVE-2021-23337",
        remediation: "Upgrade lodash to 4.17.21",
        references: ["https://nvd.nist.gov/vuln/detail/CVE-2021-23337"],
      },
    ],
    summary: {
      criticalCount: 1,
      highCount: 0,
      mediumCount: 2,
      lowCount: 1,
      infoCount: 0,
      totalFindings: 4,
      riskScore: 28,
      riskRating: "high",
      topRecommendation: "Upgrade lodash to 4.17.21",
    },
    rawData: {},
    aiAnalysis: "Fix the critical dependency and rotate the leaked key.",
  };

  it("returns an array of block objects", () => {
    const blocks = formatReportForSlack(mockReport);
    expect(Array.isArray(blocks)).toBe(true);
    expect(blocks.length).toBeGreaterThan(0);
  });

  it("includes risk rating and score", () => {
    const blocks = formatReportForSlack(mockReport);
    const json = JSON.stringify(blocks);
    expect(json).toContain("28");
    expect(json).toContain("HIGH");
  });

  it("includes scan ID in footer", () => {
    const blocks = formatReportForSlack(mockReport);
    const json = JSON.stringify(blocks);
    expect(json).toContain("scan-test-001");
  });

  it("uses ðŸ”´ emoji for critical rating", () => {
    const criticalReport = {
      ...mockReport,
      summary: { ...mockReport.summary, riskRating: "critical" as const, riskScore: 75 },
    };
    const blocks = formatReportForSlack(criticalReport);
    const json = JSON.stringify(blocks);
    expect(json).toContain("ðŸ”´");
  });

  it("uses âœ… emoji for clean rating", () => {
    const cleanReport = {
      ...mockReport,
      findings: [],
      summary: {
        ...mockReport.summary,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        totalFindings: 0,
        riskScore: 0,
        riskRating: "clean" as const,
      },
    };
    const blocks = formatReportForSlack(cleanReport);
    const json = JSON.stringify(blocks);
    expect(json).toContain("âœ…");
  });
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  GitHub Issue Posting
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

describe("postReportAsGitHubIssue", () => {
  it("returns a GitHub issue URL", async () => {
    const mockReport: PentestReport = {
      scanId: "scan-gh-001",
      target: "freakme.fun",
      scanType: "web-security",
      startedAt: new Date(),
      completedAt: new Date(),
      findings: [],
      summary: {
        criticalCount: 0, highCount: 1, mediumCount: 0, lowCount: 0, infoCount: 0,
        totalFindings: 1, riskScore: 10, riskRating: "high",
        topRecommendation: "Add CSP header",
      },
      rawData: {},
      aiAnalysis: "Add content security policy.",
    };

    const url = await postReportAsGitHubIssue("Tolani-Corp", "freakme.fun", mockReport);
    expect(url).toBe("https://github.com/org/repo/issues/99");
  });
});
